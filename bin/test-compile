#!/usr/bin/env bash
# bin/test-compile <build-dir> <cache-dir> <env-dir>

# fail fast
set -euo pipefail

BUILDPACK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && cd .. && pwd)"
source "${BUILDPACK_DIR}/lib/common.sh"
source "${BUILDPACK_DIR}/lib/util.sh"

BUILD_DIR="${1}"
CACHE_DIR="${2}"
ENV_DIR="${3}"

export GRADLE_TASK="testClasses"

"${BUILDPACK_DIR}/bin/compile" "${BUILD_DIR}" "${CACHE_DIR}" "${ENV_DIR}"

# Copy the contents of the Gradle user home to the build directory so that configuration
# and build caches are available as runtime for tests.
util::cache_copy ".gradle" "${CACHE_DIR}" "${BUILD_DIR}"

# We need to resolve the testRuntime dependencies for the tests to run, but Gradle doesn't have a built-in way to do this.
# Instead, we use a custom init script to resolve the dependencies.
# https://docs.gradle.org/current/userguide/init_scripts.html
heroku_gradle_init_script=$(mktemp)
cat << EOF > "${heroku_gradle_init_script}"
apply plugin:HerokuInitPlugin

class HerokuInitPlugin implements Plugin<Gradle> {
	@Override
	void apply(Gradle gradle) {
		gradle.allprojects{ project ->
			project.task('resolveTestRuntime') {
				doLast {
				  project.configurations.testRuntime.resolve()
				}
			}
		}
	}
}
EOF

echo "-----> Resolving testRuntime dependencies..."
(cd "${BUILD_DIR}" && ./gradlew --init-script "${heroku_gradle_init_script}" resolveTestRuntime) 2>&1 | output::indent

# Write the Gradle user home back into the cache to make sure the test dependencies get permanently cached too.
util::cache_copy ".gradle" "${BUILD_DIR}" "${CACHE_DIR}"

mkdir -p "${BUILD_DIR}/.profile.d"
cat <<-EOF >"${BUILD_DIR}/.profile.d/gradle.sh"
	export GRADLE_USER_HOME="\${HOME}/.gradle"
EOF
